# Overlap GRanges with plyranges

Objective: compute overlaps and summary statistics between two sets of
genomic ranges. In particular, suppose we want to compute the mean
genomic extent of genes in a set of query ranges.

We move on from the classroom example by seeing how we compute
overlaps when the features are in genomic space. We will use *GRanges*
in the Bioconductor package *GenomicRanges* to represent the features
and *plyranges* to compute the overlaps, similarly to how we used
*dplyr* to compute the overlaps in the previous analysis. So
data.frame is to *dplyr* as GRanges is to *plyranges*.

```{r message=FALSE}
library(plyranges)
```

Note the structure of the *GRanges* object:

```{r}
r <- GRanges("chr1", IRanges(1 + c(34e6,36e6,36.6e6),
                             width=c(2e5,2e5,1e5)),
             strand=c("+","-","-"),
             range_id=factor(c("foo","bar","boo")))
r
```

In case you haven't seen this before, *GRanges* objects have specific
functions to pull out information. See `?GRanges` for details.

```{r}
length(r)
seqnames(r)
strand(r)
```

Let's find which genes overlap a region of interest. We will load the Ensembl genes, here from a Bioconductor data package (usually we would obtain these from AnnotationHub). The last lines use convenience functions to convert to, e.g. `"chr1"`, ..., `"chrY"`.

```{r message=FALSE}
library(EnsDb.Hsapiens.v86)
library(GenomeInfoDb)
```

```{r eval=FALSE}
g <- genes(EnsDb.Hsapiens.v86)
g <- g %>% plyranges::select(gene_name)
g <- keepStandardChromosomes(g, pruning.mode="coarse")
seqlevelsStyle(g) <- "UCSC"
save(g, file="data/ens_genes.rda")
```

```{r echo=FALSE}
load("data/ens_genes.rda")
```

Now we are ready to test for overlaps. A left join gives us all the
overlaps for ranges on the left side. If a range on the left has
no overlaps it appears with `NA` for the metadata columns of the right
side ranges.

```{r}
r %>% join_overlap_left(g)
```

If we want to exclude the zero matches cases, we can use an inner
join:

```{r}
r %>% join_overlap_inner(g)
```

We can also perform summarization by columns either in the `r` or the
`g` object:

```{r}
r %>% join_overlap_inner(g) %>%
  group_by(range_id) %>%
  summarize(count=n())
```

This is giving us the same information as the following:

```{r}
r %>% count_overlaps(g)
```

If we want the gene ranges, we swap order of the ranges in the
command:

```{r}
g %>% join_overlap_inner(r)
```

If we want strand specific overlaps, we can add `_directed`:

```{r}
g %>% join_overlap_inner_directed(r)
```

Now we can access, e.g. the genomic extent of the genes (first base to
last base).

```{r}
g %>% join_overlap_inner_directed(r) %>%
  group_by(range_id) %>%
  summarize(count=n(), mean_width=mean(width))
```

What about `"boo"`? We need to add a `complete()` call to account for
the fact that we are missing those overlaps after the join. We need to
call the function explicitly from the *tidyr* package but by not
loading the package we can avoid some function name conflicts with
*plyranges*. Also we need to convert to tibble (explanation
follows).

```{r}
library(tibble)
g %>% join_overlap_inner_directed(r) %>%
  group_by(range_id) %>%
  summarize(count=n(), mean_width=mean(width)) %>%
  as_tibble() %>%
  tidyr::complete(range_id, fill=list(count=0))
```

Why did we have to convert to tibble before running `complete()`?
This is because metadata columns of *GRanges* objects are in a format
called *DataFrame* which the *tidyr* / *dplyr* functions don't know
how to operate on. To access these metadata columns, you can use any
of these types of calls:

```{r}
mcols(r)
mcols(r)$range_id
r$range_id # this works also
mcols(r)[["range_id"]] # for programmatic access
```

But if you want to work on them in with *tidyr* / *dplyr*, you need to
first convert to tibble (or data.frame):

```{r}
mcols(r) %>% as_tibble()
```
