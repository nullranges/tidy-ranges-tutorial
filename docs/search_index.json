[["index.html", "Tidy Ranges Tutorial About", " Tidy Ranges Tutorial nullranges devel team 2021-12-14 About We provide examples of computing operations on genomic ranges using the tidy data philosophy. These examples focus on the packages dplyr, plyranges, nullranges, and excluderanges. "],["join-is-an-overlap.html", "Chapter 1 Join is an overlap", " Chapter 1 Join is an overlap Objective: learn that a “join” is like an overlap. We start with a quick example explaining why we use functions called join. library(dplyr) library(tidyr) library(randomNames) Let’s set up a simulation where we have 17 classmates (not counting ourselves) in a school of 118. Suppose every member of the class has 12 friends outside of class. We want to find out, for each classmate, how many friends we have in common and also, of our shared friends, what is a typical birthday. Let’s define typical as the median birthday of our shared friends. m &lt;- 17 # size of class n &lt;- 100 # size of others in school nf &lt;- 12 # number of friends outside class set.seed(5) people &lt;- randomNames(m + n, name.order=&quot;first.last&quot;, name.sep=&quot; &quot;) We define the population of potential friends (those outside the class) as pop, and our 12 friends are in friends. Finally, we define the people that are in our class as class_people. pop &lt;- data.frame(person=people[-(1:m)], birthday=sample(31, n, TRUE)) friends &lt;- data.frame(friend=sample(people, nf)) class_people &lt;- people[1:m] The following sets up a data.frame, where each row gives, for a given classmate, their friends, and the friends’ birthdays. loop &lt;- rep(1:m, each=nf) idx &lt;- as.vector(replicate(m, sample(n, nf))) class &lt;- data.frame(classmate=class_people[loop], friend=pop$person[idx], birthday=pop$birthday[idx]) Sort this by classmate alphabetically, and make classmate into a factor. This last step is important, as it will help us to keep track of the classmates for whom we share no friends outside of class. class &lt;- class %&gt;% arrange(classmate) %&gt;% mutate(classmate=factor(classmate)) We perform an inner_join by \"friend\". This just means we look for classmates where we have overlapping friends, and we drop the rows where we don’t share any friends. “Inner” refers to the fact that we are keeping the overlap in the inside of two intersecting circles. Note that the join operation brings along the metadata (extra data) about the friends’ birthdays. shared_friends &lt;- friends %&gt;% inner_join(class, by=&quot;friend&quot;) %&gt;% arrange(classmate, friend) %&gt;% relocate(classmate) # classmate to 1st column shared_friends ## classmate friend birthday ## 1 Brandon Jones Christopher Rivera 13 ## 2 Brandon Jones Jose Jimenez 26 ## 3 Brandon Jones Maria Hernandez 15 ## 4 Brandon Jones Tuli Hoang 7 ## 5 Christopher Herron Tuli Hoang 7 ## 6 Christopher Herron William Steinbach 15 ## 7 Haley Polhamus Cellene Millhone 23 ## 8 Haley Polhamus William Steinbach 15 ## 9 Juan Villegas Cabrera Alyssa Kinanee 30 ## 10 Juan Villegas Cabrera Malik Gammon 5 ## 11 Juan Villegas Cabrera Tajhae Bohanna 31 ## 12 Maisara el-Arshad Kaylyn Judkins 2 ## 13 Maisara el-Arshad Maria Hernandez 15 ## 14 Maisara el-Arshad Tajhae Bohanna 31 ## 15 Michael Mcgill Christopher Rivera 13 ## 16 Michael Mcgill Maria Hernandez 15 ## 17 Noah Pettinger Kaylyn Judkins 2 ## 18 Noah Pettinger Tajhae Bohanna 31 ## 19 Orion Villani Malik Gammon 5 ## 20 Shane Ranaldi Alyssa Kinanee 30 ## 21 Shane Ranaldi William Steinbach 15 ## 22 Stephanie Hernandez Asmaa el-Abdelnour 29 ## 23 Zachary Roe-Huffman Maria Hernandez 15 Lastly, we perform some summarization: compute the number of friends in common with n() and the median birthday of shared friends. The complete call at the end fills in 0 for those classmates for whom we share no friends (here, the use of factor earlier becomes relevant). shared_friends %&gt;% group_by(classmate) %&gt;% summarize(in_common=n(), median_bday=median(birthday)) %&gt;% complete(classmate, fill=list(count=0)) ## # A tibble: 17 × 3 ## classmate in_common median_bday ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Aaliyah Minter NA NA ## 2 Brandon Jones 4 14 ## 3 Christopher Herron 2 11 ## 4 Collin Leon NA NA ## 5 Haley Polhamus 2 19 ## 6 Juan Villegas Cabrera 3 30 ## 7 Khaalid el-Ammar NA NA ## 8 Kianna Mcalevy NA NA ## 9 Maazin al-Ismael NA NA ## 10 Maisara el-Arshad 3 15 ## 11 Michael Mcgill 2 14 ## 12 Noah Pettinger 2 16.5 ## 13 Orion Villani 1 5 ## 14 Shane Ranaldi 2 22.5 ## 15 Stephanie Hernandez 1 29 ## 16 Xavier Urueta NA NA ## 17 Zachary Roe-Huffman 1 15 "],["overlap-granges-with-plyranges.html", "Chapter 2 Overlap GRanges with plyranges", " Chapter 2 Overlap GRanges with plyranges Objective: compute overlaps and summary statistics between two sets of genomic ranges. In particular, suppose we want to compute the mean genomic extent of genes in a set of query ranges. We move on from the classroom example by seeing how we compute overlaps when the features are in genomic space. We will use GRanges in the Bioconductor package GenomicRanges to represent the features and plyranges to compute the overlaps, similarly to how we used dplyr to compute the overlaps in the previous analysis. So data.frame is to dplyr as GRanges is to plyranges. library(plyranges) Note the structure of the GRanges object: r &lt;- GRanges(&quot;chr1&quot;, IRanges(1 + c(34e6,36e6,36.6e6), width=c(2e5,2e5,1e5)), strand=c(&quot;+&quot;,&quot;-&quot;,&quot;-&quot;), range_id=factor(c(&quot;foo&quot;,&quot;bar&quot;,&quot;boo&quot;))) r ## GRanges object with 3 ranges and 1 metadata column: ## seqnames ranges strand | range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; ## [1] chr1 34000001-34200000 + | foo ## [2] chr1 36000001-36200000 - | bar ## [3] chr1 36600001-36700000 - | boo ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths In case you haven’t seen this before, GRanges objects have specific functions to pull out information. See ?GRanges for details. length(r) ## [1] 3 seqnames(r) ## factor-Rle of length 3 with 1 run ## Lengths: 3 ## Values : chr1 ## Levels(1): chr1 strand(r) ## factor-Rle of length 3 with 2 runs ## Lengths: 1 2 ## Values : + - ## Levels(3): + - * Let’s find which genes overlap a region of interest: library(EnsDb.Hsapiens.v86) g &lt;- genes(EnsDb.Hsapiens.v86) g &lt;- g %&gt;% plyranges::select(gene_name) The following lines use convenience functions to convert to, e.g. \"chr1\", …, \"chrY\". library(GenomeInfoDb) g &lt;- keepStandardChromosomes(g, pruning.mode=&quot;coarse&quot;) seqlevelsStyle(g) &lt;- &quot;UCSC&quot; Now we are ready to test for overlaps. A left join gives us all the overlaps for ranges on the left side. If a range on the left has no overlaps it appears with NA for the metadata columns of the right side ranges. r %&gt;% join_overlap_left(g) ## GRanges object with 13 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo CSMD2 ## [2] chr1 34000001-34200000 + | foo RNA5SP42 ## [3] chr1 34000001-34200000 + | foo C1orf94 ## [4] chr1 36000001-36200000 - | bar AGO3 ## [5] chr1 36000001-36200000 - | bar RP4-665N4.8 ## ... ... ... ... . ... ... ## [9] chr1 36000001-36200000 - | bar COL8A2 ## [10] chr1 36000001-36200000 - | bar TRAPPC3 ## [11] chr1 36000001-36200000 - | bar MAP7D1 ## [12] chr1 36000001-36200000 - | bar RN7SL131P ## [13] chr1 36600001-36700000 - | boo FTLP18 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to exclude the zero matches cases, we can use an inner join: r %&gt;% join_overlap_inner(g) ## GRanges object with 13 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo CSMD2 ## [2] chr1 34000001-34200000 + | foo RNA5SP42 ## [3] chr1 34000001-34200000 + | foo C1orf94 ## [4] chr1 36000001-36200000 - | bar AGO3 ## [5] chr1 36000001-36200000 - | bar RP4-665N4.8 ## ... ... ... ... . ... ... ## [9] chr1 36000001-36200000 - | bar COL8A2 ## [10] chr1 36000001-36200000 - | bar TRAPPC3 ## [11] chr1 36000001-36200000 - | bar MAP7D1 ## [12] chr1 36000001-36200000 - | bar RN7SL131P ## [13] chr1 36600001-36700000 - | boo FTLP18 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths We can also perform summarization by columns either in the r or the g object: r %&gt;% join_overlap_inner(g) %&gt;% group_by(range_id) %&gt;% summarize(count=n()) ## DataFrame with 3 rows and 2 columns ## range_id count ## &lt;factor&gt; &lt;integer&gt; ## 1 bar 9 ## 2 boo 1 ## 3 foo 3 This is giving us the same information as the following: r %&gt;% count_overlaps(g) ## [1] 3 9 1 If we want the gene ranges, we swap order of the ranges in the command: g %&gt;% join_overlap_inner(r) ## GRanges object with 13 ranges and 2 metadata columns: ## seqnames ranges strand | gene_name range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## ENSG00000121904 chr1 33513999-34165842 - | CSMD2 foo ## ENSG00000201148 chr1 34112949-34113063 + | RNA5SP42 foo ## ENSG00000142698 chr1 34166883-34219131 + | C1orf94 foo ## ENSG00000126070 chr1 35930718-36072500 + | AGO3 bar ## ENSG00000271554 chr1 35992109-36013630 - | RP4-665N4.8 bar ## ... ... ... ... . ... ... ## ENSG00000171812 chr1 36095236-36125220 - | COL8A2 bar ## ENSG00000054116 chr1 36136570-36156053 - | TRAPPC3 bar ## ENSG00000116871 chr1 36155579-36180849 + | MAP7D1 bar ## ENSG00000264592 chr1 36191915-36192170 + | RN7SL131P bar ## ENSG00000230214 chr1 36630335-36630857 + | FTLP18 boo ## ------- ## seqinfo: 25 sequences from hg38 genome If we want strand specific overlaps, we can add _directed: g %&gt;% join_overlap_inner_directed(r) ## GRanges object with 6 ranges and 2 metadata columns: ## seqnames ranges strand | gene_name range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## ENSG00000201148 chr1 34112949-34113063 + | RNA5SP42 foo ## ENSG00000142698 chr1 34166883-34219131 + | C1orf94 foo ## ENSG00000271554 chr1 35992109-36013630 - | RP4-665N4.8 bar ## ENSG00000232862 chr1 36080066-36084026 - | RP4-665N4.4 bar ## ENSG00000171812 chr1 36095236-36125220 - | COL8A2 bar ## ENSG00000054116 chr1 36136570-36156053 - | TRAPPC3 bar ## ------- ## seqinfo: 25 sequences from hg38 genome Now we can access, e.g. the genomic extent of the genes (first base to last base). g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) ## DataFrame with 2 rows and 3 columns ## range_id count mean_width ## &lt;factor&gt; &lt;integer&gt; &lt;numeric&gt; ## 1 bar 4 18738 ## 2 foo 2 26182 What about \"boo\"? We need to add a complete() call to account for the fact that we are missing those overlaps after the join. We need to call the function explicitly from the tidyr package but by not loading the package we can avoid some function name conflicts with plyranges. Also we need to convert to data.frame (explanation follows). g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) %&gt;% as.data.frame() %&gt;% tidyr::complete(range_id, fill=list(count=0)) ## # A tibble: 3 × 3 ## range_id count mean_width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 bar 4 18738 ## 2 boo 0 NA ## 3 foo 2 26182 Why did we have to convert to data.frame before running complete()? This is because metadata columns of GRanges objects are in a format called DataFrame which the tidyr / dplyr functions don’t know how to operate on. To access these metadata columns, you can use any of these types of calls: mcols(r) ## DataFrame with 3 rows and 1 column ## range_id ## &lt;factor&gt; ## 1 foo ## 2 bar ## 3 boo mcols(r)$range_id ## [1] foo bar boo ## Levels: bar boo foo r$range_id # this works also ## [1] foo bar boo ## Levels: bar boo foo mcols(r)[[&quot;range_id&quot;]] # for programmatic access ## [1] foo bar boo ## Levels: bar boo foo "],["tissue-specific-promoter-marks.html", "Chapter 3 Tissue-specific promoter marks", " Chapter 3 Tissue-specific promoter marks Objective: determine if promoters marks (e.g. H3K27ac) are specific to genes that are expressed in a tissue-specific manner. We will load expression data from the GTEx project (Lonsdale and others 2013), which gives median expression in TPM for each tissue. We will use H3K27ac ChIP-seq data from the ENCODE project (Dunham and others 2012). library(tidyr) file &lt;- &quot;data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz&quot; gtex &lt;- read.delim(file, skip=2) We select two tissues, bladder and kidney, and convert the data from a wide format into a tidy format. tissues &lt;- gtex %&gt;% dplyr::select(Name, Bladder, Kidney...Cortex) %&gt;% dplyr::rename(gene = Name, Kidney = Kidney...Cortex) %&gt;% dplyr::mutate(gene = sub(&quot;\\\\..*&quot;,&quot;&quot;,gene)) %&gt;% pivot_longer(!gene, names_to=&quot;tissue&quot;, values_to=&quot;tpm&quot;) Now define two vectors of genes that are specific to bladder and kidney: bladder_expr &lt;- tissues %&gt;% dplyr::filter(tissue == &quot;Bladder&quot; &amp; tpm &gt; 10) %&gt;% dplyr::pull(gene) kidney_expr &lt;- tissues %&gt;% dplyr::filter(tissue == &quot;Kidney&quot; &amp; tpm &gt; 10) %&gt;% dplyr::pull(gene) int &lt;- intersect(bladder_expr, kidney_expr) bladder_expr &lt;- setdiff(bladder_expr, int) kidney_expr &lt;- setdiff(kidney_expr, int) Next, use an existing TxDb to locate these genes in the genomes. While we usually recommend to use GENCODE genes for human analysis, because the ENCODE chromatin modification peak files on AnnotationHub are in hg19, we use the UCSC hg19 genes here for simplicity of the code: library(TxDb.Hsapiens.UCSC.hg19.knownGene) library(org.Hs.eg.db) Add the ENSEMBL ID and pull out the two tissue-specific sets. g &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) ## 403 genes were dropped because they have exons located on both strands ## of the same reference sequence or on more than one reference sequence, ## so cannot be represented by a single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a ## GRangesList object, or use suppressMessages() to suppress this message. library(plyranges) g &lt;- g %&gt;% mutate(ensembl = mapIds(org.Hs.eg.db, gene_id, &quot;ENSEMBL&quot;, &quot;ENTREZID&quot;)) bladder_g &lt;- g %&gt;% filter(ensembl %in% bladder_expr) kidney_g &lt;- g %&gt;% filter(ensembl %in% kidney_expr) Finally we combine the two sets with bind_ranges, and we change the feature size from the whole gene extent (the range from the leftmost exon to rightmost exon), to just the TSS, using anchor_5p and mutate. tss &lt;- bind_ranges(bladder=bladder_g, kidney=kidney_g, .id=&quot;gtissue&quot;) %&gt;% anchor_5p() %&gt;% mutate(width=1) Now we will obtain the H3K27ac peak sets: library(AnnotationHub) ah &lt;- AnnotationHub() # query(ah, c(&quot;Homo sapiens&quot;, &quot;bladder&quot;, &quot;H3K27ac&quot;, &quot;narrowPeak&quot;)) bladder_pks &lt;- ah[[&quot;AH44180&quot;]] # query(ah, c(&quot;Homo sapiens&quot;, &quot;kidney&quot;, &quot;H3K27ac&quot;, &quot;narrowPeak&quot;)) kidney_pks &lt;- ah[[&quot;AH43443&quot;]] We download these and scale so they have the same 90% quantile of signalValue. ninety &lt;- function(x) quantile(x, .9, names=FALSE) bladder_pks &lt;- bladder_pks %&gt;% mutate(signal = signalValue / ninety(signalValue)) kidney_pks &lt;- kidney_pks %&gt;% mutate(signal = signalValue / ninety(signalValue)) Combine the peaks from bladder and kidney, filter to those with &lt; 0.1% FDR, and center the peak on the summit (the peak column gives the shift from the left side to the summit). pks &lt;- bind_ranges(bladder=bladder_pks, kidney=kidney_pks, .id=&quot;ptissue&quot;) %&gt;% filter(qValue &gt; 3, width &lt;= 1000) %&gt;% mutate(start = start + peak) %&gt;% select(-peak) %&gt;% mutate(width = 1) Finally, once we have two tidy range sets, the plyranges analysis is just a few lines. It appears that tissue-specific peaks are enriched near the tissue-specific genes for both bladder and kidney. tss %&gt;% join_overlap_left(pks, maxgap=500) %&gt;% group_by(gtissue, ptissue) %&gt;% summarize(count = n(), meanSignal = mean(signal)) ## DataFrame with 6 rows and 4 columns ## gtissue ptissue count meanSignal ## &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; &lt;numeric&gt; ## 1 bladder bladder 3065 1.182096 ## 2 bladder kidney 2100 0.919537 ## 3 bladder NA 862 NA ## 4 kidney bladder 131 0.985926 ## 5 kidney kidney 261 0.712519 ## 6 kidney NA 243 NA What’s wrong with this analysis? We didn’t figure out the expressed promoter, we just looked at the left or rightmost isoform (for + or - strand genes, respectively). References "],["bootstrap-overlap.html", "Chapter 4 Bootstrap overlap", " Chapter 4 Bootstrap overlap Objective: determine if one set of peaks are overlapping another set of peaks more or less than expected when comparing to sets of null features. The null features can be generated in a variety of ways – here we will generate them by resampling large blocks of one of the peak sets. The motivation for sampling blocks, instead of placing features uniformly along the chromosome (“shuffling”), is to better preserve inter-feature distances, because genomic features tend to cluster in the genome, even after considering things like excluded regions. This technique of generating null feature sets is called block bootstrap resampling, and we will use the nullranges implementation of the block bootstrapping algorithm to generate the null features, followed by overlap analysis with plyranges. The approach used in nullranges to generate bootstrap ranges closely follows the method described by Bickel et al. (2010). We start by loading the ENCODE kidney and bladder H3K27ac ChIP-seq peaks used in the previous analysis (Dunham and others 2012). library(AnnotationHub) ah &lt;- AnnotationHub() kidney_pks &lt;- ah[[&quot;AH43443&quot;]] bladder_pks &lt;- ah[[&quot;AH44180&quot;]] We will additionally obtain an excluded region set, so that we avoid placing bootstrap features into regions of the genome that don’t typically have features. A variety of possible exclude lists are provided by the excluderanges packages and available via AnnotationHub. Here we will use the hg19.Crawford.wgEncodeDukeMapabilityRegionsExcludable regions, as they are available for hg19, which is the genome used with the peak sets. # query(ah, c(&quot;excluderanges&quot;,&quot;hg19&quot;)) exclude &lt;- ah[[&quot;AH95912&quot;]] To make the code more generic, we will rename the kidney peaks to x and the bladder peaks to y. We will be looking for overlaps with features in x as the query set: how many of the features in x overlap features in y? The following code reduces our analysis to looking only at standard chromosomes, excluding the mitochondrial genome (too small for including in the block bootstrap). library(GenomeInfoDb) x &lt;- kidney_pks y &lt;- bladder_pks x &lt;- keepStandardChromosomes(x) seqlevels(x, pruning.mode=&quot;coarse&quot;) &lt;- setdiff(seqlevels(x), &quot;chrM&quot;) seqlevels(y, pruning.mode=&quot;coarse&quot;) &lt;- seqlevels(x) seqlevels(exclude, pruning.mode=&quot;coarse&quot;) &lt;- seqlevels(x) We are mostly concerned with avoiding placing bootstrapped features in large regions in the exclude list, so we subset the exclude list to features larger than 500 bp. library(plyranges) exclude &lt;- exclude %&gt;% filter(width(exclude) &gt;= 500) We also subset to the peaks for kidney and bladder which have q-value less than 0.001 and signal value greater than 9 (these are arbitrary filter values, just for demonstration). For further analysis, we will need the features in y to be sorted, for the bootstrapping, here we sort both sets. q_thr &lt;- 3 s_thr &lt;- 9 x &lt;- x %&gt;% filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() y &lt;- y %&gt;% filter(qValue &gt; q_thr &amp; signalValue &gt; s_thr) %&gt;% sort() Now we can assess how many overlaps we observed between x and y: obs &lt;- x %&gt;% mutate(n_overlaps = count_overlaps(., y)) obs %&gt;% summarize(total = sum(n_overlaps)) ## DataFrame with 1 row and 1 column ## total ## &lt;integer&gt; ## 1 5073 table( obs$n_overlaps ) ## ## 0 1 2 3 4 6 ## 9453 3966 486 39 3 1 We can check if any of the features of y fall in the excluded regions: y %&gt;% mutate(n_overlaps = count_overlaps(., exclude)) %&gt;% summarize(total = sum(n_overlaps)) ## DataFrame with 1 row and 1 column ## total ## &lt;integer&gt; ## 1 0 The following chunk of code does the bootstrapping of features in y. Here we subset first to metadata columns of interest (an id variable that we create, and the signal value which we rename to signal). pks_to_boot &lt;- y %&gt;% mutate(id = seq_along(y)) %&gt;% select(id, signal = signalValue) The bootRanges function returns the 100 bootstrap feature sets combined into one GRanges object – this tidy format facilitates downstream analysis as we will see. The bootstrap iteration is stored in the iter metadata column. library(nullranges) R &lt;- 100 # number of iterations set.seed(5) # set seed for reproducibility boots &lt;- bootRanges(pks_to_boot, blockLength=5e5, R=R, exclude=exclude) boots ## bootRanges object with 582286 ranges and 5 metadata columns: ## seqnames ranges strand | id signal block ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt; ## [1] chr1 2011397-2011809 * | 931 14.42934 5 ## [2] chr1 2011973-2012399 * | 932 17.57052 5 ## [3] chr1 2012505-2013073 * | 933 9.64691 5 ## [4] chr1 2503670-2505748 * | 3752 20.84181 6 ## [5] chr1 2505855-2507134 * | 3753 15.29241 6 ## ... ... ... ... . ... ... ... ## [582282] chrY 55017962-55019381 * | 4606 10.6726 6198 ## [582283] chrY 55020728-55021448 * | 4607 10.2813 6198 ## [582284] chrY 56057780-56058485 * | 526 10.7459 6200 ## [582285] chrY 58301237-58301561 * | 2909 13.6510 6204 ## [582286] chrY 58469665-58470750 * | 2910 16.2352 6204 ## iter blockLength ## &lt;Rle&gt; &lt;Rle&gt; ## [1] 1 500000 ## [2] 1 500000 ## [3] 1 500000 ## [4] 1 500000 ## [5] 1 500000 ## ... ... ... ## [582282] 100 500000 ## [582283] 100 500000 ## [582284] 100 500000 ## [582285] 100 500000 ## [582286] 100 500000 ## ------- ## seqinfo: 24 sequences from hg19 genome The default use above of the exclude argument is to drop bootstrapped ranges that overlap the exclude list. We can examine properties of permuted y over iterations, and compare to the original y. To do so, we first add the original features as iter=0. combined &lt;- pks_to_boot %&gt;% mutate(iter=0) %&gt;% bind_ranges(boots) %&gt;% select(iter) Then compute summaries: stats &lt;- combined %&gt;% group_by(iter) %&gt;% summarize(n = n(), sum_width=sum(width)/1e6) %&gt;% as.data.frame() Original y vs bootstrap: stats[1,] ## iter n sum_width ## 1 0 5838 5.068015 summary(stats[-1,]) ## iter n sum_width ## 1 : 1 Min. :5586 Min. :4.778 ## 2 : 1 1st Qu.:5727 1st Qu.:4.966 ## 3 : 1 Median :5814 Median :5.065 ## 4 : 1 Mean :5823 Mean :5.055 ## 5 : 1 3rd Qu.:5911 3rd Qu.:5.131 ## 6 : 1 Max. :6180 Max. :5.375 ## (Other):94 We can also look at distributions of various aspects, e.g. here the width of features, across a few of the bootstraps and the original feature set y. library(ggplot2) library(ggridges) combined %&gt;% filter(iter %in% 0:5) %&gt;% select(iter) %&gt;% as.data.frame() %&gt;% mutate(type = ifelse(iter == 0, &quot;original&quot;, &quot;boot&quot;)) %&gt;% ggplot(aes(log10(width), iter, fill=type)) + geom_density_ridges(alpha = 0.75) + geom_text(data=head(stats), aes(x=2.25, y=iter, label=paste0(&quot;n=&quot;,n), fill=NULL), vjust=1.5) To compute overlap with the null features, we need the complete() function from the tidyr package. We saw complete() before – this is used in the case that one of the iterations has no overlaps. In this case, we need to record the 0 value for proper inference and plots downstream. It is rare we would have no overlaps with so many features as we have in x and y but it’s good practice to leave the complete() as part of the workflow so the code works correctly in all cases. The overlap per iteration of the bootstrap is accomplished by a series of plyranges / dplyr commands (we switch to dplyr halfway through, after the as.data.frame() call). library(tidyr) null &lt;- x %&gt;% join_overlap_inner(boots) %&gt;% group_by(iter) %&gt;% summarize(n_overlaps = n()) %&gt;% as.data.frame() %&gt;% complete(iter, fill=list(n_overlaps = 0)) head(null) ## # A tibble: 6 × 2 ## iter n_overlaps ## &lt;fct&gt; &lt;dbl&gt; ## 1 1 60 ## 2 2 60 ## 3 3 76 ## 4 4 51 ## 5 5 39 ## 6 6 66 sum( obs$n_overlaps ) ## [1] 5073 The observed number of overlaps is about two orders of magnitude more than the bootstrapped number, which makes sense as two tissues would be expected to share a number of similar regulatory regions (as marked by H3K27ac) – more so than randomly placed genomic features, even after accounting for excluded regions and feature clustering. ggplot(null, aes(n_overlaps)) + geom_histogram(binwidth=5) + ggtitle(&quot;bootstrap overlaps&quot;) What could be improved with this analysis? Note that in the above chunks where we count overlaps, we are doubly (or triply, etc.) counting features in x if they hit more than one feature in y or boots. We can count statistics per x feature by adding another group_by into the stream of operations. This also allows us to do more complex operations, such as computing the maximum signal value for the overlapping features in y per feature in x: First add an ID variable to keep track of x features: x &lt;- x %&gt;% mutate(x_id = seq_along(x)) Then perform an inner join, and group by the new x ID: obs &lt;- x %&gt;% join_overlap_inner(pks_to_boot) %&gt;% group_by(x_id) %&gt;% summarize(num_overlaps = n(), max_signal = max(signal)) sum( obs$num_overlaps &gt; 0 ) ## [1] 4495 summary( obs$max_signal ) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.002 10.281 12.025 13.029 14.725 35.211 For the bootstrap ranges overlap step, we also need to add iter to the initial group_by, so we count per x feature and per iteration of the bootstrap: null &lt;- x %&gt;% join_overlap_inner(boots) %&gt;% group_by(x_id, iter) %&gt;% summarize(num_overlaps = n()) %&gt;% as.data.frame() %&gt;% group_by(iter) %&gt;% summarize(any_hits = sum(num_overlaps &gt; 0)) %&gt;% complete(iter, fill=list(any_hits = 0)) head(null) ## # A tibble: 6 × 2 ## iter any_hits ## &lt;fct&gt; &lt;dbl&gt; ## 1 1 55 ## 2 2 55 ## 3 3 68 ## 4 4 50 ## 5 5 37 ## 6 6 63 Still, we are seeing much more overlap in the observed data than in the bootstrap data: sum( obs$num_overlaps &gt; 0 ) / mean(null$any_hits) ## [1] 76.7851 The above code chunk then avoids double counting. We could also have made other per-x-feature statistics in the summarize step after the initial group_by, such as maximum signal of overlapping features. What other ways could we have done this analysis? Suppose we don’t just want the count of overlaps, but the rate of overlaps from the y perspective, keeping track of the variable number of features per bootstrap. We demonstrate one approach to obtain this rate for the bootstraps: x_thin &lt;- x %&gt;% select(x_id) null &lt;- boots %&gt;% select(id, iter) %&gt;% join_overlap_inner(x_thin) %&gt;% group_by(id, iter) %&gt;% summarize(num_overlaps = n()) %&gt;% as.data.frame() %&gt;% group_by(iter) %&gt;% summarize(any_hits = sum(num_overlaps &gt; 0)) %&gt;% complete(iter, fill=list(any_hits = 0)) Now combine with the per-iteration total count: totals &lt;- boots %&gt;% group_by(iter) %&gt;% summarize(total=n()) %&gt;% as.data.frame() null %&gt;% dplyr::left_join(totals) %&gt;% mutate(rate = any_hits/total) ## Joining, by = &quot;iter&quot; ## # A tibble: 100 × 4 ## iter any_hits total rate ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 59 6031 0.00978 ## 2 2 58 5710 0.0102 ## 3 3 73 5758 0.0127 ## 4 4 50 5927 0.00844 ## 5 5 37 5713 0.00648 ## 6 6 59 5888 0.0100 ## 7 7 58 5910 0.00981 ## 8 8 79 5836 0.0135 ## 9 9 59 5770 0.0102 ## 10 10 50 5991 0.00835 ## # … with 90 more rows References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
