[["overlap-granges-with-plyranges.html", "Chapter 2 Overlap GRanges with plyranges", " Chapter 2 Overlap GRanges with plyranges Objective: compute overlaps and summary statistics between two sets of genomic ranges. In particular, suppose we want to compute the mean genomic extent (distance from left-most to right-most basepair) of genes overlapping a set of query ranges. We move on from the “classroom example” by seeing how we compute overlaps when the features are in genomic space. We will use GRanges in the Bioconductor package GenomicRanges to represent the features and plyranges to compute the overlaps, similarly to how we used dplyr to compute the overlaps in the previous analysis. So data.frame is to dplyr as GRanges is to plyranges. library(plyranges) Note the structure of the GRanges object: r &lt;- GRanges(&quot;chr1&quot;, IRanges(1 + c(34e6,36e6,36.6e6), width=c(2e5,2e5,1e5)), strand=c(&quot;+&quot;,&quot;-&quot;,&quot;-&quot;), range_id=factor(c(&quot;foo&quot;,&quot;bar&quot;,&quot;boo&quot;))) r ## GRanges object with 3 ranges and 1 metadata column: ## seqnames ranges strand | range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; ## [1] chr1 34000001-34200000 + | foo ## [2] chr1 36000001-36200000 - | bar ## [3] chr1 36600001-36700000 - | boo ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths In case you haven’t seen this before, GRanges objects have specific functions to pull out information. See ?GRanges for details. length(r) ## [1] 3 seqnames(r) ## factor-Rle of length 3 with 1 run ## Lengths: 3 ## Values : chr1 ## Levels(1): chr1 strand(r) ## factor-Rle of length 3 with 2 runs ## Lengths: 1 2 ## Values : + - ## Levels(3): + - * Let’s find which genes overlap a region of interest. We will load the Ensembl genes, here from a Bioconductor data package (usually we would obtain these from AnnotationHub). The last lines use convenience functions to convert to, e.g. \"chr1\", …, \"chrY\". library(EnsDb.Hsapiens.v86) library(GenomeInfoDb) g &lt;- genes(EnsDb.Hsapiens.v86) g &lt;- g %&gt;% plyranges::select(gene_name) g &lt;- keepStandardChromosomes(g, pruning.mode=&quot;coarse&quot;) seqlevelsStyle(g) &lt;- &quot;UCSC&quot; save(g, file=&quot;data/ens_genes.rda&quot;) Now we are ready to test for overlaps. A left join gives us all the overlaps for ranges on the left side (here r). If a range on the left has no overlaps it appears with NA for the metadata columns of the right side ranges. If a range on the left side has multiple overlaps with the right side, it will appear multiple times in the output. More below on how to deal with this, if it is desired to have statistics on per-range overlaps. r %&gt;% join_overlap_left(g) ## GRanges object with 13 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo CSMD2 ## [2] chr1 34000001-34200000 + | foo RNA5SP42 ## [3] chr1 34000001-34200000 + | foo C1orf94 ## [4] chr1 36000001-36200000 - | bar AGO3 ## [5] chr1 36000001-36200000 - | bar RP4-665N4.8 ## ... ... ... ... . ... ... ## [9] chr1 36000001-36200000 - | bar COL8A2 ## [10] chr1 36000001-36200000 - | bar TRAPPC3 ## [11] chr1 36000001-36200000 - | bar MAP7D1 ## [12] chr1 36000001-36200000 - | bar RN7SL131P ## [13] chr1 36600001-36700000 - | boo FTLP18 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to exclude the zero matches cases, we can use an inner join: r %&gt;% join_overlap_inner(g) ## GRanges object with 13 ranges and 2 metadata columns: ## seqnames ranges strand | range_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt; ## [1] chr1 34000001-34200000 + | foo CSMD2 ## [2] chr1 34000001-34200000 + | foo RNA5SP42 ## [3] chr1 34000001-34200000 + | foo C1orf94 ## [4] chr1 36000001-36200000 - | bar AGO3 ## [5] chr1 36000001-36200000 - | bar RP4-665N4.8 ## ... ... ... ... . ... ... ## [9] chr1 36000001-36200000 - | bar COL8A2 ## [10] chr1 36000001-36200000 - | bar TRAPPC3 ## [11] chr1 36000001-36200000 - | bar MAP7D1 ## [12] chr1 36000001-36200000 - | bar RN7SL131P ## [13] chr1 36600001-36700000 - | boo FTLP18 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths We can also perform summarization by columns either in the r or the g object: r %&gt;% join_overlap_inner(g) %&gt;% group_by(range_id) %&gt;% summarize(count=n()) ## DataFrame with 3 rows and 2 columns ## range_id count ## &lt;factor&gt; &lt;integer&gt; ## 1 bar 9 ## 2 boo 1 ## 3 foo 3 This is giving us the same information as the following: r %&gt;% count_overlaps(g) ## [1] 3 9 1 Which can be added to the range data with a mutate call: r %&gt;% mutate(overlaps = count_overlaps(., g)) ## GRanges object with 3 ranges and 2 metadata columns: ## seqnames ranges strand | range_id overlaps ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; ## [1] chr1 34000001-34200000 + | foo 3 ## [2] chr1 36000001-36200000 - | bar 9 ## [3] chr1 36600001-36700000 - | boo 1 ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we don’t care about multiple overlaps, but just want a binary variable that records if there was one or more overlaps or not, we can ask if the count of overlaps is greater than 0: r %&gt;% mutate(overlaps_any = count_overlaps(., g) &gt; 0) ## GRanges object with 3 ranges and 2 metadata columns: ## seqnames ranges strand | range_id overlaps_any ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;logical&gt; ## [1] chr1 34000001-34200000 + | foo TRUE ## [2] chr1 36000001-36200000 - | bar TRUE ## [3] chr1 36600001-36700000 - | boo TRUE ## ------- ## seqinfo: 1 sequence from an unspecified genome; no seqlengths If we want to keep the information about the gene ranges, we swap the order of the ranges in the command: g %&gt;% join_overlap_inner(r) ## GRanges object with 13 ranges and 2 metadata columns: ## seqnames ranges strand | gene_name range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## ENSG00000121904 chr1 33513999-34165842 - | CSMD2 foo ## ENSG00000201148 chr1 34112949-34113063 + | RNA5SP42 foo ## ENSG00000142698 chr1 34166883-34219131 + | C1orf94 foo ## ENSG00000126070 chr1 35930718-36072500 + | AGO3 bar ## ENSG00000271554 chr1 35992109-36013630 - | RP4-665N4.8 bar ## ... ... ... ... . ... ... ## ENSG00000171812 chr1 36095236-36125220 - | COL8A2 bar ## ENSG00000054116 chr1 36136570-36156053 - | TRAPPC3 bar ## ENSG00000116871 chr1 36155579-36180849 + | MAP7D1 bar ## ENSG00000264592 chr1 36191915-36192170 + | RN7SL131P bar ## ENSG00000230214 chr1 36630335-36630857 + | FTLP18 boo ## ------- ## seqinfo: 25 sequences from hg38 genome If we want strand specific overlaps, we can add _directed: g %&gt;% join_overlap_inner_directed(r) ## GRanges object with 6 ranges and 2 metadata columns: ## seqnames ranges strand | gene_name range_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## ENSG00000201148 chr1 34112949-34113063 + | RNA5SP42 foo ## ENSG00000142698 chr1 34166883-34219131 + | C1orf94 foo ## ENSG00000271554 chr1 35992109-36013630 - | RP4-665N4.8 bar ## ENSG00000232862 chr1 36080066-36084026 - | RP4-665N4.4 bar ## ENSG00000171812 chr1 36095236-36125220 - | COL8A2 bar ## ENSG00000054116 chr1 36136570-36156053 - | TRAPPC3 bar ## ------- ## seqinfo: 25 sequences from hg38 genome By turning the join around, we have access to the genomic range information about the genes. Now we can compute, e.g. the average genomic extent of the genes (first base to last base), per overlapping range. g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) ## DataFrame with 2 rows and 3 columns ## range_id count mean_width ## &lt;factor&gt; &lt;integer&gt; &lt;numeric&gt; ## 1 bar 4 18738 ## 2 foo 2 26182 What about \"boo\"? We need to add a complete() call to account for the fact that we are missing those overlaps after the join. We need to call the function explicitly from the tidyr package but by not loading the package we can avoid some function name conflicts with plyranges. Also we need to convert to tibble (explanation follows). library(tibble) g %&gt;% join_overlap_inner_directed(r) %&gt;% group_by(range_id) %&gt;% summarize(count=n(), mean_width=mean(width)) %&gt;% as_tibble() %&gt;% tidyr::complete(range_id, fill=list(count=0)) ## # A tibble: 3 × 3 ## range_id count mean_width ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 bar 4 18738 ## 2 boo 0 NA ## 3 foo 2 26182 Why did we have to convert to tibble before running complete()? This is because metadata columns of GRanges objects are in a format called DataFrame which the tidyr / dplyr functions don’t know how to operate on. To access these metadata columns, you can use any of these types of calls: mcols(r) ## DataFrame with 3 rows and 1 column ## range_id ## &lt;factor&gt; ## 1 foo ## 2 bar ## 3 boo mcols(r)$range_id ## [1] foo bar boo ## Levels: bar boo foo r$range_id # this works also ## [1] foo bar boo ## Levels: bar boo foo mcols(r)[[&quot;range_id&quot;]] # for programmatic access ## [1] foo bar boo ## Levels: bar boo foo But if you want to work on them in with tidyr / dplyr, you need to first convert to tibble (or data.frame): mcols(r) %&gt;% as_tibble() ## # A tibble: 3 × 1 ## range_id ## &lt;fct&gt; ## 1 foo ## 2 bar ## 3 boo "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
